{
    "collab_server" : "",
    "contents" : "\n\n\nsceua = function(OFUN, pars, lower, upper, maxn = 10000, kstop = 5, pcento = 0.01,\n    ngs = 5, npg = 5, nps = 5, nspl = 5, mings = 5, iniflg = 1, iprint = 0, iround = 3, \n    peps = 0.0001, plog = rep(FALSE,length(pars)), implicit = NULL, timeout = NULL, ...) {\n\n# OFUN - objective function\n# pars - starting values\n# lower - lower bounds\n# upper - upper bounds\n# maxn - maximum number of iterations\n# kstop - number of shuffling loops in which the criterion value must change \n#         by the given percentage before optimization is terminated\n# pcento - percentage by which the criterion value must change in given number of shuffling loops\n# ngs - number of complexes in the initial population\n# npg = number of points in each complex\n# npt = total number of points in initial population (npt=ngs*npg)\n# nps = number of points in a sub-complex\n# nspl = number of evolution steps allowed for each complex before\n#     complex shuffling\n# mings = minimum number of complexes required, if the number of\n#     complexes is allowed to reduce as the optimization proceeds\n# iniflg = flag on whether to include the initial point in population\n#     = 0, not included\n#     = 1, included\n# iprint = flag for controlling print-out after each shuffling loop\n#     = 0, print information on the best point of the population\n#      = 1, print information on every point of the population\n# implicit = function for implicit boundaries (e.g. sum(par[4]+par[5]) < 1)\n\n  oofun = function(pars) OFUN(pars, ...)\n  \n  if (!is.null(timeout)) tstart = Sys.time()\n  npars = length(pars)\n  if (length(plog) == 1) \n    plog = rep(plog,npars) \n  if (length(upper) != npars | length(lower) != npars | length(plog) != npars) \n     stop(\"pars, upper, lower and plog must be of same length, plog can alternatively be of length 1\")\n  pars = ifelse(plog,log10(pars),pars)\n  upper = ifelse(plog,log10(upper),upper)\n  lower = ifelse(plog,log10(lower),lower)\n\n  nloop = 0\n  npt = ngs * npg\n  loop = 0\n  bound = upper-lower\n  criter = rep(1e10,20)\n  parset = matrix(nrow = npt,ncol = npars)\n  xf = rep(1e10,npt)\n  icall = 1\n\n  lpars = ifelse(plog,10^pars,pars)\n  fa = oofun(lpars)\n  if (iprint > 0 && icall %% iprint == 0) cat(icall,signif(fa,iround), \"\\n\")\n  parset[1,] = pars\n  xf[1] = fa\n  stdinit = rep(1,npars)\n  for (ii in ifelse(iniflg == 1,2,1):npt) {\n    parset[ii,] = getpnt(idist = 1,lower,upper,stdinit,lower, implicit)\n    lpars = ifelse(plog,10^parset[ii,],parset[ii,])\n    xf[ii] = oofun(lpars)\n    icall = icall + 1\n    if (iprint > 0 && icall %% iprint == 0) cat(icall,round(xf[ii],iround), \"\\n\")\n  }\n\n  parset = parset[order(xf),]\n  xf = sort(xf)\n  bestpar = parset[1,]\n  worstpar = parset[npt,]\n  bestf = xf[1]\n  worstf = xf[npt]\n\n  parsttout = parstt(npt,npars,parset,bound, peps)\n  ipcnvg = parsttout$ipcnvg\n  gnrng = parsttout$gnrng\n  parstd = parsttout$parstd\n  \n  while (TRUE) {\n    nloop = nloop + 1\n    for (igs in 1:ngs) {\n      karr = (c(1:npg)-1)*ngs + igs\n      cx = parset[karr,]\n      cf = xf[karr]\n      for (loop in 1:nspl) {\n        kpos = 1\n        if (nps == npg) {\n          lcs = c(1:nps)\n        } else while(TRUE) {\n          lpos = 1+round(npg+.5-sqrt((npg+.5)^2-npg*(npg+1)*runif(1)))\n          lcs[kpos] = lpos\n          if (sum(duplicated(lcs))==0) kpos = kpos + 1\n          if (kpos > nps) break \n        }\n        lcs = sort(lcs)\n        soc = cx[lcs,]\n        sf = cf[lcs]  \n        cceout = cce(oofun, npars, nps = nps, soc = soc, sf = sf, lower = lower, \n                     upper = upper, parstd = parstd, icall = icall,\n                     maxn = maxn, iprint = iprint, iround = iround, bestf = bestf, \n                     plog = plog, implicit = implicit)\n        soc = cceout$soc\n        sf = cceout$sf\n        icall = cceout$icall\n        cx[lcs,] = soc\n        cf[lcs] = sf\n        cx = cx[order(cf),]\n        cf = sort(cf)\n        if (!is.null(timeout)) \n          if (difftime(Sys.time() - tstart, \"secs\") > timeout)\n            return(list(par = ifelse(plog,10^bestpar,bestpar), value = xf[1], \n                        convergence = list(funConvergence = signif(concrit,iround)/pcento, parConvergence = gnrng/peps),\n                        counts = icall, iterations = nloop, timeout = TRUE))\n      }\n      parset[karr,] = cx\n      xf[karr] = cf\n    }\n    parset = parset[order(xf),]\n    xf = sort(xf)\n    bestpar = parset[1,]\n    worstpar = parset[npt,]\n    bestf = xf[1]\n    worstf = xf[npt]\n    parsttout = parstt(npt,npars,parset,bound, peps)\n    ipcnvg = parsttout$ipcnvg\n    gnrng = parsttout$gnrng\n    parstd = parsttout$parstd\n    fbestf = criter[kstop]\n    concrit = 2*(fbestf-bestf)/(fbestf+bestf)\n    criter[2:length(criter)] = criter[1:(length(criter)-1)]\n    criter[1] = bestf\n    if (iprint >= 0) cat(icall,\"best\",\n        signif(bestf,iround), \"function convergence\", signif(concrit, iround)/pcento,\n        \"parameter convergence\", gnrng/peps, \"\\n\")\n\n    if (concrit < pcento & ipcnvg == 1) break\n    if (icall > maxn) break\n    if (ngs > mings) {\n      compout = comp(npars, npt, ngs, npg, parset, xf)\n      ngs = ngs -1\n      parset = compout$parset\n      xf = compout$xf\n    }\n  }\n  bestpar = ifelse(plog,10^bestpar,bestpar)\n  return(list(par = bestpar, value = xf[1], convergence = list(funConvergence = signif(concrit,iround)/pcento, parConvergence = gnrng/peps),\n      counts = icall, iterations = nloop, timeout = FALSE))\n}\n\ncomp = function(npars,npt,ngs,npg,parset,xf){\n  xn = parset\n  xfn = xf\n  for (igs in 1:ngs) {\n    karr1 = (c(1:npg)-1)*ngs + igs\n    karr2 = (c(1:npg)-1)*(ngs-1) + igs\n    xn[karr2,] = parset[karr1,]\n    xfn[karr2] = xf[karr1]\n  }\n  return(list(parset = xn, xf = xfn))\n}\n\ncce = function(oofun, npars, nps, soc, sf,lower, upper, parstd, icall, maxn, iprint, \n               iround, bestf, plog, implicit) {\n  alpha = 1.\n  beta = 0.5\n  n = dim(soc)[1]\n  sb = soc[1,]\n  sw = soc[n,]\n  ce = colMeans(soc)\n  fw = sf[n]\n  snew = ce+alpha*(ce-sw)\n#  print(icall)\n  if (chkcst(snew, lower, upper, implicit) >0) snew = getpnt(2, lower, upper, parstd, sb, implicit)\n#  print(snew)\n  lpars = ifelse(plog, 10^snew, snew)\n  fnew = oofun(lpars)\n  icall = icall + 1\n  if (iprint > 0 && icall %% iprint == 0) cat(icall, signif(fnew, iround), signif(bestf, iround), \"\\n\")\n  if (fnew > fw) {\n    snew = ce-beta*(ce-sw)\n    lpars = ifelse(plog,10^snew, snew)\n    fnew = oofun(lpars)\n    icall = icall + 1\n    if (iprint > 0 && icall %% iprint == 0) cat(icall, signif(fnew, iround), signif(bestf, iround), \"\\n\")\n    if (fnew > fw) {\n      snew = getpnt(2, lower, upper, parstd, sb, implicit)\n      lpars = ifelse(plog,10^snew, snew)\n      fnew = oofun(lpars)\n      icall = icall + 1\n      if (iprint > 0 && icall %% iprint == 0) cat(icall, signif(fnew, iround), signif(bestf, iround), \"\\n\")\n    }\n  }\n  soc[n,] = snew\n  sf[n] = fnew\n  return(list(soc = soc, sf = sf, icall = icall))\n}\n\nchkcst = function(parlocal, lower, upper, implicit) {                                                  \n ibound = if (sum(mapply(FUN = function(x,y,z)\n               max(y-x, x-z, 0), parlocal, lower, upper)) > 0) 1 else 0\n if (ibound == 0 & length(parlocal) >1 & !is.null(implicit)) {\n# Possibility to include implicit constraints \n   if (!is.function(implicit)) stop(\"implicit has to be a function\")\n   ibound = implicit(parlocal)\n }\n ibound\n}\n\n\ngetpnt = function(idist,lower,upper,std,pari, implicit){\n#  rand = (ifelse(rep(idist,npars) == 1,runif(npars),rnorm(npars)))\n#  print(xi)\n#  print(rand)\n  ic = 0\n  while (TRUE) {\n    parj = mapply(FUN = get1p, pari, std = std, lower = lower, upper = upper, \n        MoreArgs = list(idist = idist, implicit = implicit))\n    if (chkcst(parj,lower,upper, implicit) == 0) break\n    ic = ic + 1\n    if (ic > 100) stop(\"Cannot find a parameter set respecting the fixed or implicit boundaries after 100 iterations\")\n  }\n  return(parj)\n}\n\nget1p = function(pari,std,lower,upper,idist, implicit) {\n#  print(paste(xi,std,rand,lower,upper))\n  ic = 0\n  while (TRUE) {\n    rand = ifelse(idist == 1,runif(1),rnorm(1))\n    parj = pari+std*rand*(upper-lower)\n#    print(x)\n#    print(chkcst(x,lower,upper))\n    if (chkcst(parj,lower,upper, implicit) == 0) break\n    ic = ic + 1\n    if (ic > 100) stop(\"Not possible to find a parameter that respect the fixed or implicit boundaries after 100 iterations\")\n    #    print(acdf)\n  }\n  return(parj)\n}\n\nparstt = function(npt,npars,parset,bound, peps) {\n  parstd = apply(parset,MARGIN=2,FUN = function(x) sd(x))/bound\n  parmin = apply(parset,MARGIN=2,FUN = function(x) min(x))\n  parmax = apply(parset,MARGIN=2,FUN = function(x) max(x))\n  gsum = sum(log((parmax-parmin)/bound))\n  gnrng = exp(gsum/npars)\n  ipcnvg = ifelse(gnrng <=peps, 1, 0)\n  return(list(ipcnvg = ipcnvg,gnrng = gnrng,parstd = parstd))\n}\n\n\n#FUN = function(pars,target) (pars[1]*pars[2]*pars[3]-target)^2\n\n#p0 = c(1,1,1)\n#upper = c(20,20,20)\n#lower = c(-20,-20,-20)\n#best = sceua(FUN,p0,bl,bu,plog=FALSE,target = 3.75)\n# plog is a logical to define if parameters should be logarithmized or not",
    "created" : 1585840353569.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3006066966",
    "id" : "2F69EA69",
    "lastKnownWriteTime" : 1520585839,
    "last_content_update" : 1520585839,
    "path" : "D:/R/rtop/R/sceua.R",
    "project_path" : "R/sceua.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}